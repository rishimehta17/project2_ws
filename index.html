<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UR5 3D Drawing with Object Avoidance</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f0f1e;
      overflow: hidden;
    }

    #toolbar {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(20, 20, 40, 0.95);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      z-index: 100;
      min-width: 300px;
      border: 2px solid rgba(100, 200, 255, 0.3);
    }

    h1 {
      color: #64d8ff;
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 15px;
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-group label {
      color: #aaa;
      font-size: 13px;
      display: block;
      margin-bottom: 8px;
    }

    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 8px;
      transition: all 0.2s;
    }

    .btn:hover {
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    #sendBtn {
      background: #00d4aa;
      color: white;
    }

    #clearBtn {
      background: #ff4757;
      color: white;
    }

    #undoBtn {
      background: #ffa502;
      color: white;
    }

    #loadBtn {
      background: #3742fa;
      color: white;
    }

    input[type="color"] {
      width: 100%;
      height: 40px;
      border: 2px solid rgba(100, 200, 255, 0.3);
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 10px;
      outline: none;
      background: rgba(100, 200, 255, 0.2);
      cursor: pointer;
    }

    input[type="file"] {
      width: 100%;
      padding: 8px;
      border: 2px solid rgba(100, 200, 255, 0.3);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      color: #aaa;
      font-size: 12px;
      cursor: pointer;
    }

    .value-display {
      color: #64d8ff;
      font-size: 12px;
      margin-top: 5px;
      text-align: center;
    }

    .warning {
      background: rgba(255, 71, 87, 0.2);
      border: 2px solid #ff4757;
      padding: 10px;
      border-radius: 8px;
      color: #ff4757;
      font-size: 12px;
      margin-top: 10px;
      display: none;
    }

    #status {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 40, 0.95);
      color: #64d8ff;
      padding: 12px 25px;
      border-radius: 25px;
      font-size: 14px;
      z-index: 100;
      border: 2px solid rgba(100, 200, 255, 0.3);
    }

    .status-error {
      background: rgba(255, 71, 87, 0.95) !important;
      border-color: #ff4757 !important;
      color: white !important;
    }

    #instructions {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(20, 20, 40, 0.95);
      padding: 15px;
      border-radius: 15px;
      color: #aaa;
      z-index: 100;
      border: 2px solid rgba(100, 200, 255, 0.3);
      max-width: 220px;
      font-size: 12px;
      line-height: 1.8;
    }

    #instructions strong {
      color: #64d8ff;
    }
  </style>
</head>

<body>

  <div id="toolbar">
    <h1>üé® 3D Drawing + Collision</h1>

    <div class="control-group">
      <label>Drawing Plane:</label>
      <select id="planeSelector"
        style="width:100%; padding:10px; border-radius:8px; background:rgba(0,0,0,0.3); color:white; border:2px solid rgba(100,200,255,0.3); cursor:pointer;">
        <option value="xz" selected>XY Plane (Table / Top View)</option>
        <option value="xy">XZ Plane (Vertical / Front View)</option>
        <option value="yz">YZ Plane (Vertical / Side View)</option>
      </select>
    </div>

    <div class="control-group">
      <label>Plane Position (Offset):</label>
      <input type="range" id="planeOffset" min="-50" max="50" value="0">
      <div class="value-display" id="offsetDisplay">0.00</div>
    </div>

    <div class="control-group">
      <label>Load Point Cloud (.txt or .xyz):</label>
      <input type="file" id="fileInput" accept=".txt,.xyz,.ply">
      <button class="btn" id="loadBtn">Load Sample Object</button>
    </div>

    <div class="control-group">
      <label>Color:</label>
      <input type="color" id="colorPicker" value="#00d4aa">
    </div>

    <div class="control-group">
      <label>Size:</label>
      <input type="range" id="brushSize" min="1" max="8" value="3">
      <div class="value-display" id="sizeDisplay">3</div>
    </div>

    <button class="btn" id="undoBtn">‚Ü∂ Undo</button>
    <button class="btn" id="clearBtn">Clear Drawing</button>
    <button class="btn" id="sendBtn">Send to Robot</button>

    <div class="value-display">Strokes: <span id="count">0</span></div>

    <div class="control-group"
      style="background:rgba(100,200,255,0.1); padding:10px; border-radius:8px; margin-top:10px;">
      <label style="color:#64d8ff; font-weight:bold;">Current Position:</label>
      <div class="value-display" style="font-family:monospace; font-size:11px; text-align:left;">
        X: <span id="debugX">0.00</span><br>
        Y: <span id="debugY">0.00</span><br>
        Z: <span id="debugZ">0.00</span>
      </div>
    </div>

    <div class="warning" id="collisionWarning">
      ‚ö†Ô∏è Collision detected! Drawing blocked.
    </div>
  </div>

  <div id="instructions">
    <strong>Controls:</strong><br>
    ‚Ä¢ <strong>Hold SHIFT + Left drag</strong> = Draw<br>
    ‚Ä¢ <strong>Left drag</strong> = Rotate view<br>
    ‚Ä¢ <strong>Right drag</strong> = Pan<br>
    ‚Ä¢ <strong>Scroll</strong> = Zoom<br>
    ‚Ä¢ Choose plane: XY/XZ/YZ<br>
    ‚Ä¢ Adjust plane position<br>
    ‚Ä¢ Red = collision zone!
  </div>

  <div id="status">Ready! Select a plane and start drawing.</div>

  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene Setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a15);

    // Camera
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(3, 2, 3);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = true;
    controls.panSpeed = 0.5;
    controls.rotateSpeed = 0.8;

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 5);
    scene.add(light);

    // Grid
    const grid = new THREE.GridHelper(4, 40, 0x00d4aa, 0x1a1a2e);
    scene.add(grid);

    // Drawing plane
    let activePlane = 'xz'; // Default to Table (Horizontal in ThreeJS)
    let planeOffset = 0;

    const planeGeo = new THREE.PlaneGeometry(3, 2);
    const planeMat = new THREE.MeshBasicMaterial({
      color: 0x1a1a3e,
      transparent: true,
      opacity: 0.4,
      side: THREE.DoubleSide
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    updatePlaneOrientation();
    scene.add(plane);

    function updatePlaneOrientation() {
      plane.rotation.set(0, 0, 0);

      if (activePlane === 'xy') {
        // ThreeJS XY Plane (Vertical) -> Robot XZ Plane (Front View)
        plane.rotation.x = 0;
        plane.position.set(0, 0.5, planeOffset); // Depth offset
      } else if (activePlane === 'xz') {
        // ThreeJS XZ Plane (Horizontal) -> Robot XY Plane (Table View)
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(0, 0.5 + planeOffset, 0); // Height offset
      } else if (activePlane === 'yz') {
        // ThreeJS YZ Plane (Side) -> Robot YZ Plane (Side View)
        plane.rotation.y = Math.PI / 2;
        plane.position.set(planeOffset, 0.5, 0); // Side offset
      }
    }

    // Robot Representation (Visual Only)
    const robot = new THREE.Group();
    const baseMesh = new THREE.Mesh(
      new THREE.CylinderGeometry(0.12, 0.15, 0.15),
      new THREE.MeshLambertMaterial({ color: 0x2d3436 })
    );
    baseMesh.position.y = 0.075;
    robot.add(baseMesh);
    scene.add(robot);

    // Collision & Point Cloud Logic
    let pointCloud = null;
    let collisionObject = null;
    const collisionRadius = 0.15;

    function createSampleObject() {
      if (pointCloud) scene.remove(pointCloud);
      if (collisionObject) scene.remove(collisionObject);

      const pointsGeo = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const numPoints = 5000;
      const radius = 0.3;

      for (let i = 0; i < numPoints; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta) + 0.5;
        const z = radius * Math.cos(phi);
        positions.push(x, y, z);
        colors.push(0.2, 0.8, 1.0);
      }

      pointsGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      pointsGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const pointsMat = new THREE.PointsMaterial({ size: 0.015, vertexColors: true, transparent: true, opacity: 0.8 });
      pointCloud = new THREE.Points(pointsGeo, pointsMat);
      scene.add(pointCloud);

      const collisionGeo = new THREE.SphereGeometry(radius + collisionRadius, 32, 32);
      const collisionMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.0, wireframe: true });
      collisionObject = new THREE.Mesh(collisionGeo, collisionMat);
      collisionObject.position.y = 0.5;
      scene.add(collisionObject);

      status.textContent = 'Sample sphere loaded! Draw around it.';
    }

    document.getElementById('loadBtn').addEventListener('click', createSampleObject);

    // File Input Loading
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        // Logic to parse .txt/.xyz files would go here (simplified for brevity but placeholder remains)
        status.textContent = "File loaded (visuals placeholder)";
      };
      reader.readAsText(file);
    });


    // State Variables
    let drawing = false;
    let currentStroke = [];
    let allStrokes = [];
    let currentColor = '#00d4aa';
    let currentSize = 3;
    let isShiftPressed = false;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const lineGroup = new THREE.Group();
    scene.add(lineGroup);

    // UI Elements
    const status = document.getElementById('status');
    const count = document.getElementById('count');
    const brushSize = document.getElementById('brushSize');
    const sizeDisplay = document.getElementById('sizeDisplay');
    const colorPicker = document.getElementById('colorPicker');
    const collisionWarning = document.getElementById('collisionWarning');
    const planeSelector = document.getElementById('planeSelector');
    const planeOffsetSlider = document.getElementById('planeOffset');
    const offsetDisplay = document.getElementById('offsetDisplay');
    const debugX = document.getElementById('debugX');
    const debugY = document.getElementById('debugY');
    const debugZ = document.getElementById('debugZ');

    brushSize.oninput = () => { currentSize = parseInt(brushSize.value); sizeDisplay.textContent = currentSize; };
    colorPicker.oninput = () => { currentColor = colorPicker.value; };
    planeSelector.onchange = () => { activePlane = planeSelector.value; updatePlaneOrientation(); status.textContent = `Drawing on ${planeSelector.options[planeSelector.selectedIndex].text}`; };
    planeOffsetSlider.oninput = () => { planeOffset = parseFloat(planeOffsetSlider.value) / 100; offsetDisplay.textContent = planeOffset.toFixed(2); updatePlaneOrientation(); };

    window.addEventListener('keydown', (e) => { if (e.key === 'Shift') isShiftPressed = true; });
    window.addEventListener('keyup', (e) => { if (e.key === 'Shift') isShiftPressed = false; });

    // Get 3D point helper
    function getPoint(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObject(plane);

      if (hits.length > 0) {
        const p = hits[0].point.clone();
        // Constrain points to the visual plane
        if (activePlane === 'xy') p.z = plane.position.z;
        else if (activePlane === 'xz') p.y = plane.position.y;
        else if (activePlane === 'yz') p.x = plane.position.x;
        return p;
      }
      return null;
    }

    function checkCollision(point) {
      if (!collisionObject) return false;
      const distance = point.distanceTo(collisionObject.position);
      const radius = collisionObject.geometry.parameters.radius || 0.3;
      return distance < radius;
    }

    // Drawing Logic
    let currentLine = null;
    let hasCollision = false;

    renderer.domElement.onmousedown = (e) => {
      if (!isShiftPressed || e.button !== 0) return;
      const p = getPoint(e);
      if (!p) return;

      if (checkCollision(p)) {
        hasCollision = true;
        collisionWarning.style.display = 'block';
        return;
      }

      drawing = true;
      currentStroke = [p];

      const geometry = new THREE.BufferGeometry();
      const material = new THREE.LineBasicMaterial({ color: new THREE.Color(currentColor), linewidth: currentSize });
      currentLine = new THREE.Line(geometry, material);
      lineGroup.add(currentLine);
    };

    renderer.domElement.onmousemove = (e) => {
      const p = getPoint(e);
      if (p) {
        debugX.textContent = p.x.toFixed(2);
        debugY.textContent = p.y.toFixed(2);
        debugZ.textContent = p.z.toFixed(2);
      }

      if (!drawing) return;
      if (checkCollision(p)) {
        hasCollision = true;
        collisionWarning.style.display = 'block';
        if (collisionObject) collisionObject.material.opacity = 0.3;
        return;
      }
      currentStroke.push(p);
      currentLine.geometry.setFromPoints(currentStroke);
    };

    renderer.domElement.onmouseup = () => {
      if (drawing) {
        if (hasCollision) {
          if (currentLine) lineGroup.remove(currentLine);
          setTimeout(() => { collisionWarning.style.display = 'none'; }, 1000);
        } else if (currentStroke.length > 1) {
          allStrokes.push({ points: currentStroke.map(p => p.clone()), color: currentColor, size: currentSize });
          count.textContent = allStrokes.length;
        }
      }
      drawing = false;
      hasCollision = false;
      currentStroke = [];
    };

    document.getElementById('undoBtn').onclick = () => {
      if (allStrokes.length === 0) return;
      allStrokes.pop();
      rebuildLines();
      count.textContent = allStrokes.length;
    };

    document.getElementById('clearBtn').onclick = () => {
      allStrokes = [];
      rebuildLines();
      count.textContent = 0;
    };

    function rebuildLines() {
      lineGroup.clear();
      allStrokes.forEach(stroke => {
        const geo = new THREE.BufferGeometry().setFromPoints(stroke.points);
        const mat = new THREE.LineBasicMaterial({ color: new THREE.Color(stroke.color) });
        const line = new THREE.Line(geo, mat);
        lineGroup.add(line);
      });
    }

    // === SEND LOGIC ===
    document.getElementById('sendBtn').onclick = () => {
      if (!allStrokes.length) {
        status.textContent = 'Draw something first!';
        return;
      }

      const ws = new WebSocket('ws://127.0.0.1:8765');

      ws.onopen = () => {
        status.textContent = 'Sending...';
        allStrokes.forEach((stroke, i) => {
          setTimeout(() => {
            const points = stroke.points.map(p => {
              // --- COORDINATE MAPPING ---
              // 1. U (Screen X) comes from ThreeJS X
              const u = Math.round(((p.x + 1.5) / 3) * 1280);

              // 2. V (Screen Y/Depth) comes from ThreeJS Z
              const v = Math.round((1 - (p.z + 1) / 2) * 720);

              // 3. Robot Z (Height) comes from ThreeJS Y
              const z_height = p.y;

              return [u, v, z_height];
            });

            ws.send(JSON.stringify({
              type: 'stroke',
              points: points
            }));
          }, i * 200);
        });

        setTimeout(() => {
          status.textContent = 'Sent to robot!';
          ws.close();
        }, allStrokes.length * 200 + 500);
      };

      ws.onerror = () => {
        status.textContent = 'Error: Start python script first!';
      };
    };

    window.onresize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Initialize
    updatePlaneOrientation();
    animate();
    setTimeout(createSampleObject, 500);

  </script>
</body>

</html>